---
import workExperience from "../data/work-experience.json";
import { formatISODate } from "../utils/date-formatter";
import BaseLayout from "../layouts/BaseLayout.astro";
import ArrowIcon from "../components/ArrowIcon.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";

interface WorkExperienceEntry {
  company: {
    name: string;
    img: string;
  };
  startDate: string;
  endDate: string | null;
  title: string;
  description: string;
}

const formatExperienceData = (data: WorkExperienceEntry[]) =>
  data.map((experience) => ({
    ...experience,
    startDate: formatISODate(experience.startDate),
    endDate: experience.endDate ? formatISODate(experience.endDate) : "Present"
  }));

const formattedExperienceData = formatExperienceData(workExperience as WorkExperienceEntry[]);
---

<BaseLayout title="Curriculum Vitae | Martín Palmieri" description="Professional experience and background of Martín Palmieri.">
  <Header />
  <main
    class="main-container h-[calc(100vh-62px)] w-full snap-y snap-mandatory overflow-y-scroll scroll-smooth lg:h-[calc(100vh-88px)]"
    aria-label="Professional experience timeline"
  >
    {
      formattedExperienceData.map(
        ({ company, title, startDate, endDate, description }) => (
          <section
            class="flex h-[calc(100vh-62px)] w-full snap-center flex-col items-start px-6 pt-10 md:px-10 lg:h-[calc(100vh-88px)] lg:flex-row"
          >
            <div class="mb-4 w-full lg:mb-0 lg:w-1/2 lg:pr-8">
              <h1 class="font-title text-4xl md:text-6xl lg:text-8xl">{company.name}</h1>
            </div>
            <div class="w-full lg:w-1/2">
              <h3 class="text-xl font-bold text-gray-700 md:text-2xl lg:text-3xl">
                {startDate} - {endDate}
              </h3>
              <h2 class="mb-3 text-2xl font-extrabold md:text-4xl lg:mb-4 lg:text-5xl">{title}</h2>
              <p class="text-lg font-normal leading-relaxed md:text-xl lg:text-2xl">{description}</p>
            </div>
          </section>
        )
      )
    }
  </main>
  <div class="fixed left-1/2 bottom-[100px] z-10 -translate-x-1/2 md:bottom-10 flex flex-col items-center">
    <ArrowIcon direction="up" />
    <ArrowIcon direction="down" />
  </div>
  <Footer />
</BaseLayout>

<script is:inline data-astro-rerun>
  let teardown = null;

  const setupNavigation = () => {
    const mainContainer = document.querySelector(".main-container");
    const moreDownButton = document.querySelector('[data-direction="down"]');
    const moreUpButton = document.querySelector('[data-direction="up"]');

    if (
      !(mainContainer instanceof HTMLElement) ||
      !(moreDownButton instanceof HTMLButtonElement) ||
      !(moreUpButton instanceof HTMLButtonElement)
    ) {
      console.error("One or more elements could not be found in the document.");
      return () => {};
    }

    const sections = Array.from(mainContainer.querySelectorAll("section"));

    if (sections.length === 0) {
      console.error("No sections were found inside the main container.");
      return () => {};
    }

    let activeIndex = 0;
    let sectionPositions = [];

    const setArrowVisibility = (index) => {
      moreUpButton.classList.toggle("invisible", index === 0);
      moreDownButton.classList.toggle(
        "invisible",
        index === sections.length - 1
      );
    };

    const ensureSectionPositions = () => {
      if (sectionPositions.length !== sections.length) {
        sectionPositions = sections.map(
          (section) => section.offsetTop - mainContainer.offsetTop
        );
      }
    };

    const scrollToIndex = (index) => {
      ensureSectionPositions();
      const target = sectionPositions[index];

      if (!Number.isFinite(target)) {
        return;
      }

      activeIndex = index;
      setArrowVisibility(index);
      mainContainer.scrollTo({
        top: target,
        behavior: "smooth"
      });
    };

    const scrollToNextSection = () => {
      const nextIndex = Math.min(activeIndex + 1, sections.length - 1);

      if (nextIndex !== activeIndex) {
        scrollToIndex(nextIndex);
      }
    };

    const scrollToPreviousSection = () => {
      const previousIndex = Math.max(activeIndex - 1, 0);

      if (previousIndex !== activeIndex) {
        scrollToIndex(previousIndex);
      }
    };

    const handleKeyDown = (event) => {
      if (event.key === "ArrowDown" || event.key === "PageDown") {
        event.preventDefault();
        scrollToNextSection();
      } else if (event.key === "ArrowUp" || event.key === "PageUp") {
        event.preventDefault();
        scrollToPreviousSection();
      }
    };

    const handleArrowClick = (event) => {
      event.preventDefault();

      if (event.currentTarget === moreDownButton) {
        scrollToNextSection();
      } else {
        scrollToPreviousSection();
      }
    };

    const intersectionObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) {
            return;
          }

          const index = sections.indexOf(entry.target);

          if (index === -1 || index === activeIndex) {
            return;
          }

          activeIndex = index;
          setArrowVisibility(activeIndex);
        });
      },
      {
        root: mainContainer,
        threshold: 0.6
      }
    );

    sections.forEach((section) => intersectionObserver.observe(section));

    moreDownButton.addEventListener("click", handleArrowClick);
    moreUpButton.addEventListener("click", handleArrowClick);
    document.addEventListener("keydown", handleKeyDown);

    window.requestAnimationFrame(() => {
      ensureSectionPositions();

      const visibleIndex = sections.findIndex((section, index) => {
        const top = sectionPositions[index];
        const bottom = top + section.clientHeight;
        const scrollMiddle =
          mainContainer.scrollTop + mainContainer.clientHeight / 2;

        return scrollMiddle >= top && scrollMiddle < bottom;
      });

      if (visibleIndex >= 0) {
        activeIndex = visibleIndex;
      }

      setArrowVisibility(activeIndex);
    });

    const handleResize = () => {
      sectionPositions = [];
      ensureSectionPositions();
      const currentIndex = sections.findIndex((section, index) => {
        const top = sectionPositions[index];
        const bottom = top + section.clientHeight;
        const scrollMiddle =
          mainContainer.scrollTop + mainContainer.clientHeight / 2;

        return scrollMiddle >= top && scrollMiddle < bottom;
      });

      if (currentIndex >= 0 && currentIndex !== activeIndex) {
        activeIndex = currentIndex;
      }

      setArrowVisibility(activeIndex);
    };

    window.addEventListener("resize", handleResize);

    const cleanup = () => {
      intersectionObserver.disconnect();
      moreDownButton.removeEventListener("click", handleArrowClick);
      moreUpButton.removeEventListener("click", handleArrowClick);
      document.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("resize", handleResize);
    };

    const handleBeforeSwap = () => {
      cleanup();
    };

    document.addEventListener("astro:before-swap", handleBeforeSwap, {
      once: true
    });

    return () => {
      cleanup();
      document.removeEventListener("astro:before-swap", handleBeforeSwap);
    };
  };

  const initializeNavigation = () => {
    if (typeof teardown === "function") {
      teardown();
    }

    teardown = setupNavigation();
  };

  if (document.readyState === "complete" || document.readyState === "interactive") {
    initializeNavigation();
  } else {
    document.addEventListener("DOMContentLoaded", initializeNavigation, {
      once: true
    });
  }

  document.addEventListener("astro:page-load", initializeNavigation);
</script>
